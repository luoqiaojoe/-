### let

+ `let` 为js带来了块级作用域
+ `let` 不存在变量提升，如果在用`let`声明的变量之前访问该变量，会报错 ReferenceError
+ 暂时性死区。只要块级作用域内存在 `let` 命令，它所声明的变量就“绑定”这个区域，不再收外部的影响

```
var n = 1;
if(true){
    n = 10; // ReferenceError
    let n;
}
```

> ES6 明确规定，如果区块中存在`let`和`const`命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。

“暂时性死区”也意味着`typeof`不再是一个百分之一百安全的操作
```
typeof x; // ReferenceError
let x;
```
在`let`出现之前，利用`typeof`检测一个未声明的变量时，不会报错，而是返回`undefined`；所以也提醒我们，变量一定要在声明之后再使用。

> 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。


### const

`const`声明一个只读的常量。这也意味着，`const`一旦声明变量，就必须立即初始化，不能留到以后赋值。
`const`也存在暂时性死区。


### ES6 声明变量的6种方法

ES5 只有两种声明变量的方法：`var`命令和`function`，命令。
ES6 除了`let`和`const`外，还有`import`和`class`命令。
